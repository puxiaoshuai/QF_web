<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
       
    </style>
</head>

<body>
    <p>
        我们知道，变量根据作用域的不同分为两种：全局变量和局部变量。
    </p>
    <p>
        函数内部可以访问全局变量和局部变量。</p>
    <p>
        函数外部只能访问全局变量，不能访问局部变量。
    </p>
    <p>

    当函数执行完毕，本作用域内的局部变量会销毁。
    </p>
    
    <p style="color: red;">
        简单理解就是：如果这个作用域可以访问另外一个函数内部的局部变量，那就产生了闭包（此时，你可以把闭包理解成是一种现象）；而另外那个作用域所在的函数称之为闭包函数。注意，这里强调的是访问局部变量哦。
    </p>
    <p>闭包的作用：延伸变量的作用范围</p>
    <p>由于作用域的原因，我们无法在函数外访问函数里面定义的变量，但有时候我们又会有这样的需求，这个时候我们就需要使用闭包了。</p>
    <p style="color: red;">注意事项:由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 </p>
    <p>解决办法</p>
    <p>2.解决方法是，在退出函数之前，将不使用的局部变量全部删除。
        如将当前变量的值设置为“null”，将变量的引用解除，当垃圾回收启动时，会自动对这些值为“null”的变量回收</p>
    <script>
        // 第一步：
        // function A() {  
        //     let name=100
        // }
        // //不能访问到 函数中的函数变量
        // let c=A()
        // console.log(c.a);
        // 进阶=======================
        function A() {  
            var a=100;
            
            function getA() {
                return a;
              }
              return {
                  get:getA
              }
        }
        //上面就是闭包
        let my=A()
        console.log(my.get());
        
        
        
       
        
    </script>
</body>

</html>