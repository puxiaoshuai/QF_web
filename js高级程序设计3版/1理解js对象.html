<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js对象</title>
</head>
<body>
     <p>对象的属性类型 Configurable,Enumerable,Get,Set</p>
     <hr>
     <p>对象的创建1，工厂模式</p>
     <p>对象的创建，构造函数模式</p>
     <p>原型模式</p>
     <p>组合使用构造函数和原型模式</p>
     <p>寄生构造函数</p>
     <hr>
     <p>继承就要使用到原型链</p>
     <h3>(8)什么对象能作为构造函数，能具有原型属性prototype</h3>
     <p>所有Function的实例对象 (如：function,Array，Object......等数据类型) ，能够new出属于他们自己的实例，能够具有原型属性prototype</p>
    <script>
        // 早期对象的创建
       let person=new Object()
       person.name="蒲小帅"
       console.log(person);
       //现在对象的创建，对象字面量
       let student={
           name:"普洱",
           sayhi:function(){
               alert(this.name)
           }
       }
    //    数据属性
    Object.defineProperty(student,"age",{
        value:"18",
        configurable:false ,//能否通过delete删除属性进行重新定义
        enumerable:false, //能否通过for-in进行循环遍历
        writable:false,//能否修改属性的值
    })
    student.age="26"
    console.log(student);
    
    // 原型模式
    function Dog(){

    }
    console.log("11",Dog);
    
    Dog.prototype={
        name:"小花狗",
        age:"2"
    }
    let dog=new Dog()
    dog.age="3"
    console.log(dog);
    // studengt
    function Teacher(){
      name:"张三"   
     }
     let tea=new Teacher()
     let c=tea.__proto__
     let d=Teacher.prototype
     console.log(c);
     console.log(d);
     console.log(c===d);//true
     //他们是相等的，
     
     var a=1;
     var a=2;
     //不能重复 
    //  let b="1"
    //  let b="12"
    // 递归
    function add1(m,n){
        if(m===n){
          return m+n
        }else if(m>n){    
            //5,10
            // 5+6+7+8+9
            return  add1(n+1,m)
        }
        else if(n>m){
            //5,10 6
            return  add1(m+1,n)
        }
    }
    let all1=add1(2,4)
    console.log(all1);
    
     

    

       
       
       

       
    </script>
</body>
</html>